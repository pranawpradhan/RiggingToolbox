/*
 *  Copyright 2010-2014 Fabric Engine Inc. All rights reserved.
 */

require Math;
require Geometry;


//////////////////////////////////////
// Factory definition.

object DeltaMushModifierFactory : GeometryOperatorFactory {
};

function GeometryOperator DeltaMushModifierFactory.constructGeometryOperator(){
  DeltaMushModifier geomOp();
  return geomOp;
}


//////////////////////////////////////
//


object DeltaMushModifier : BaseModifier {
  Vec3 deltas[][];
  Vec3 positionsBuffer[][];

  UInt32 iterations;
  Boolean bound;
  String referenceGeometryNames[];
  PolygonMesh referenceGeometries[];
  UInt32 boundVersion;

  Boolean useMask;
  String maskWeightmapName;

  Boolean displayDebugging;
  Lines lines[]; //Used to display debugging information.
  DrawingHandle handle;
};


function DeltaMushModifier(){
  this.iterations = 20;
  this.useMask = false;
  this.maskWeightmapName = '';
}



function UInt32[String] DeltaMushModifier.getAttributeInteractions(){
  UInt32 result[String];
  result['positions'] = AttrMode_ReadWrite;
  result['normals'] = AttrMode_ReadWrite;
  if(this.useMask)
    result[this.maskWeightmapName] = AttrMode_Read;
  return result;
}

function DeltaMushModifier.setNumIterations!(UInt32 iterations){
  if(this.iterations != iterations){
    this.iterations = iterations;
    this.bound = false;
    String data;
    this.notify('changed', data);
  }
}


function DeltaMushModifier.setUseMask!(Boolean useMask){
  if(this.useMask != useMask){
    this.useMask = useMask;
    String data;
    this.notify('changed', data);
  }
}

function DeltaMushModifier.setDisplayDebugging!(Boolean displayDebugging){
  if(this.displayDebugging != displayDebugging){
    this.displayDebugging = displayDebugging;
    String data;
    this.notify('changed', data);
  }
}


function Mat44 deltaMushModifier_buildRefFrame(PolygonMeshTopology mesh, UInt32 index, Vec3 positionValues[]){

  Mat44 m;
  Vec3 p1 = positionValues[index];

  LocalL16UInt32Array surroundingPoints;
  mesh.getPointSurroundingPoints( index, false, surroundingPoints );
  UInt32 nbNei = surroundingPoints.size();
  if( nbNei == 0 ) 
    return m;
  Vec3 p2 = positionValues[surroundingPoints.get(0)];
  Vec3 p3 = positionValues[surroundingPoints.get(1)];

  Vec3 dir = p2 - p1;
  Vec3 nrm = dir.cross(p3 - p1);
  Quat q;
  q.setFromDirectionAndUpvector(dir, nrm);
  m.set(p1, q.toMat33(), Vec3(1,1,1));
  return m;
}


operator deltaMushModifier_smoothPos<<<index>>>(PolygonMeshTopology mesh, Vec3 srcPositions[], io Vec3 tgtPositions[]) {

  //Pseudo-gaussian: center weight = 0.5, neighbor weights sum = 0.5
  Vec3 position = srcPositions[ index ];

  LocalL16UInt32Array surroundingPoints;
  mesh.getPointSurroundingPoints( index, false, surroundingPoints );
  UInt32 nbNei = surroundingPoints.size();
  if( nbNei ) {
    Vec3 neiSum = Vec3(0,0,0);
    for( UInt32 i = 0; i < nbNei; ++i ) {
      UInt32 neiPt = surroundingPoints.get(i);
      neiSum += srcPositions[neiPt];
    }
    neiSum /= Scalar(nbNei);
    position = ( position + neiSum ) * 0.5;
    mesh.setPointAttribute( index, tgtPositions, position );
  }
}

// operator deltaMushModifier_smoothPosNorm<<<index>>>(io Vec3 positions[], io Vec3 normals[], io PolygonMesh mesh) {
//   //Pseudo-gaussian: center weight = 0.5, neighbor weights sum = 0.5
//   Vec3 position = positions[ index ];
//   Vec3 normal = normals[ index ];

//   LocalL16UInt32Array surroundingPoints;
//   mesh.getPointSurroundingPoints( index, false, surroundingPoints );
//   UInt32 nbNei = surroundingPoints.size();
//   if( nbNei ) {
//     Vec3 neiPosSum = Vec3(0,0,0);
//     Vec3 neiNormSum = Vec3(0,0,0);
//     for( UInt32 i = 0; i < nbNei; ++i ) {
//       UInt32 neiPt = surroundingPoints.get(i);
//       neiPosSum += positions[neiPt];
//       neiNormSum += normals[neiPt];
//     }
//     neiPosSum /= Scalar(nbNei);
//     mesh.setPointPosition( index, ( position + neiPosSum ) * 0.5 );
//     normal += neiNormSum;
//     normal.setUnit();
//     mesh.setPointNormal( index, normal );
//   }
// }


operator deltaMushModifier_computePointBinding<<<index>>>(
  PolygonMeshTopology mesh,
  Vec3 undeformedPositions[],
  Vec3 mushedPositions[],
  io Vec3 deltas[]
){
  // Build a reference frame. 
  Mat44 mat44 = deltaMushModifier_buildRefFrame(mesh, index, mushedPositions);

  // Compute the delta between the relaxed frame and the original position.
  deltas[index] = mat44.inverse() * undeformedPositions[index];
}


operator deltaMushModifier_applyDeltas<<<index>>>(
  PolygonMeshTopology mesh,
  io Vec3 positions[],
  Vec3 mushedPositions[],
  Vec3 deltas[],
  Boolean displayDebugging,
  io UInt32 debugLinesindices[],
  io Vec3 debugLinespositions[]
){
  Mat44 mat44 = deltaMushModifier_buildRefFrame(mesh, index, mushedPositions);
  Vec3 src = mushedPositions[index];
  Vec3 tgt = mat44 * deltas[index];
  mesh.setPointAttribute( index, positions, tgt );

  if(displayDebugging){
    debugLinesindices[(index*2)] = (index*2);
    debugLinesindices[(index*2)+1] = (index*2)+1;
    debugLinespositions[(index*2)] = src;
    debugLinespositions[(index*2)+1] = tgt;
  }
}

operator deltaMushModifier_applyDeltas_Masked<<<index>>>(
  PolygonMeshTopology mesh,
  io Vec3 positions[],
  Vec3 mushedPositions[],
  Vec3 deltas[],
  Scalar maskWeightmapValues[],
  Boolean displayDebugging,
  io UInt32 debugLinesindices[],
  io Vec3 debugLinespositions[]
){

  Vec3 src, tgt;
  if(maskWeightmapValues[index] < 1.0){
    Mat44 mat44 = deltaMushModifier_buildRefFrame(mesh, index, mushedPositions);
    src = mushedPositions[index];
    tgt = (mat44 * deltas[index]).linearInterpolate(positions[index], maskWeightmapValues[index]);
    mesh.setPointAttribute( index, positions, tgt );
  }
  else{
    src = positions[index];
    tgt = positions[index];
  }

  if(displayDebugging){
    debugLinesindices[(index*2)] = (index*2);
    debugLinesindices[(index*2)+1] = (index*2)+1;
    debugLinespositions[(index*2)] = src;
    debugLinespositions[(index*2)+1] = tgt;
  }
}

function deltaMushModifier_smoothMesh(PolygonMeshTopology mesh, UInt32 iterations, io Vec3 positionsBuffer[], io Vec3 positions[], Boolean useGPU){
  // Smoothing requires double buffers so that we can read from one buffer while writing do a different buffer.
  Vec3 srcPositions[];
  Vec3 tgtPositions[];
  srcPositions = positions;
  tgtPositions = positionsBuffer;
  for(UInt32 i=0; i<iterations; i++){
    // relax the mesh, causing it to lose volume.
    deltaMushModifier_smoothPos<<<mesh.pointCount()@useGPU>>>(mesh, srcPositions, tgtPositions);

    if(i<iterations-1){
      // Swap the buffers
      Vec3 tmp[];
      tmp = srcPositions;
      srcPositions = tgtPositions;
      tgtPositions = tmp;
    }
  }
  // For odd number of iterations, we have to do one final swap to ensure that the 
  // positionsBuffer contains the final iteration of smoothing.
  if(iterations % 2 == 1){
    positions = srcPositions;
    positionsBuffer = tgtPositions;
  }
}

operator deltaMushModifier_computeMeshBinding<<<index>>>(
  PolygonMesh referenceGeometries[],
  io Vec3 deltas[][],
  io Vec3 positionsBuffer[][],
  UInt32 iterations,
  Boolean useGPU
){
  PolygonMesh mesh = referenceGeometries[index];
  deltas[index].resize(mesh.pointCount());
  UInt32 size = mesh.positionsAttribute.values.size();
  positionsBuffer[index].resize(size);
  Vec3 undeformedPositions[];

  if(useGPU){
    if(mesh.getMemType() == 0)
      mesh.convertToGPU();
    if(mesh.positionsAttribute.getElementsMemType() == 0)
      mesh.positionsAttribute.convertToGPU();
    if(positionsBuffer[index].getElementsMemType() == 0)
      positionsBuffer[index].convertToGPU();
    if(deltas[index].getElementsMemType() == 0)
      deltas[index].convertToGPU();

    undeformedPositions.resize(size);
    undeformedPositions.convertToGPU();
    Vec3Attribute_copyFrom<<<size@true>>>(undeformedPositions, mesh.positionsAttribute.values);
  }
  else{
    if(mesh.getMemType() != 0)
      mesh.convertToCPU();
    if(mesh.positionsAttribute.getElementsMemType() != 0)
      mesh.positionsAttribute.convertToCPU();
    if(positionsBuffer[index].getElementsMemType() != 0)
      positionsBuffer[index].convertToCPU();
    if(deltas[index].getElementsMemType() != 0)
      deltas[index].convertToCPU();

    undeformedPositions = mesh.positionsAttribute.values.clone();
  }

  deltaMushModifier_smoothMesh(mesh.topology, iterations, positionsBuffer[index], mesh.positionsAttribute.values, useGPU);

  // compute the deltas between the relaxed mesh, and the original vertex positions.
  deltaMushModifier_computePointBinding<<<mesh.pointCount()@useGPU>>>(
    mesh.topology,
    undeformedPositions,
    positionsBuffer[index],
    deltas[index]
  );
}

operator deltaMushModifier_deformGeometries<<<index>>>(
  io GeometrySet geomSet,
  Vec3 deltas[][],
  io Vec3 positionsBuffer[][],
  UInt32 iterations,
  Boolean useMask,
  String maskWeightmapName,
  Boolean displayDebugging,
  io Lines lines[],
  Boolean useGPU
){
  PolygonMesh mesh = geomSet.get(0);
  if(!mesh){
    report("Warning in DeltaMushModifier: geometry is not a polygon mesh:" + getGeomDebugName(mesh));
    return;
  }

  if(displayDebugging){
    if(lines[index] == null)
      lines[index] = Lines();
    if(lines[index].lineCount() != mesh.pointCount()){
      lines[index].attributes.resize( mesh.pointCount() * 2 );
      lines[index].indices.resize( mesh.pointCount() * 2 );
      lines[index].incrementVersion();
    }
    // Always increment the positions version as they will be re-computed in the following kernel.
    lines[index].incrementPositionsVersion();
  }

  DebugLines debugLines(lines[index]);
  if(useGPU){
    debugLines.convertToGPU();
  }

  deltaMushModifier_smoothMesh(mesh.topology, iterations, positionsBuffer[index], mesh.positionsAttribute.values, useGPU);

  // Re-apply the deltas to re-inflate the mesh.
  // (Even when binding, the mesh is deflated, so it must be re-inflated)
  Ref<ScalarAttribute> weightMap = null;
  if(useMask && maskWeightmapName.length() > 0){
    weightMap = mesh.getAttribute(maskWeightmapName, ScalarAttribute);
    if(!weightMap)
      report("Warning in DeltaMushModifier: Geometry does not have the scalar attribute specified by the maskWeightmapName:"+maskWeightmapName);
  }
  if(weightMap){
    // Use a special kernel to inflate the mesh that uses the mask. 
    // this is cheaper than checking the mask in every point.
    deltaMushModifier_applyDeltas_Masked<<<mesh.pointCount()@useGPU>>>(
      mesh.topology,
      mesh.positionsAttribute.values,
      positionsBuffer[index],
      deltas[index],
      weightMap.values,
      displayDebugging,
      debugLines.indices,
      debugLines.positions
    );
  }
  else{
    deltaMushModifier_applyDeltas<<<mesh.pointCount()@useGPU>>>(
      mesh.topology,
      mesh.positionsAttribute.values,
      positionsBuffer[index],
      deltas[index],
      displayDebugging,
      debugLines.indices,
      debugLines.positions
    );
  }
  mesh.incrementPointPositionsVersion();
}

function DeltaMushModifier.evaluate!(EvalContext context, io GeometrySet geomSet){
  AutoProfilingEvent p(FUNC);
  
  // by adding the iterations to the version, simply changing iterations causes the binding to be invalidated.
  if(geomSet.getVersion()+this.iterations != this.boundVersion){
    this.bound = false;
    this.deltas.resize(geomSet.size());
    this.positionsBuffer.resize(geomSet.size());
    this.lines.resize(geomSet.size());

    // Note: We could provide a way to query the original undeformed geometry from the geomSet. 
    // As a geometry is deformed, its original values are usually cached in an Attribute cache. 
    // The original values could be attached back the geometry as meta data. This would be much cleaner
    // than loading the alembic file 2x as we do here.

    if(geomSet.size() != this.referenceGeometries.size())
      throw("Reference Geometries count:" + this.referenceGeometries.size() + " does not match the current count of the geometries in the stack:" + geomSet.size());

    for(Integer geomId=0; geomId<geomSet.size(); geomId++){
      PolygonMesh mesh = geomSet.get(geomId);
      if(!mesh || mesh.pointCount() != this.referenceGeometries[geomId].pointCount())
        throw("Reference Geometries point counts to not match the current geometries in the stack.");
    }

    deltaMushModifier_computeMeshBinding<<<geomSet.size()>>>(
      this.referenceGeometries,
      this.deltas,
      this.positionsBuffer,
      this.iterations,
      this.useGPU()
      );
  }
  if( this.iterations > 0)
    deltaMushModifier_deformGeometries<<<geomSet.size()>>>(
      geomSet,
      this.deltas,
      this.positionsBuffer,
      this.iterations,
      this.useMask,
      this.maskWeightmapName,
      this.displayDebugging,
      this.lines,
      this.useGPU()
      );

  if(!this.bound){
    this.boundVersion = geomSet.getVersion()+this.iterations;
    this.bound = true;
  }

  if(this.displayDebugging && this.handle==null && this.iterations > 0)
    this.setupRendering();
  else if((!this.displayDebugging && this.handle!=null) || this.iterations == 0)
    this.handle = null;
}

function DeltaMushModifier.setupRendering!(){

  // Construct a handle for this character instance. The handle will clean up the InlineDrawing when it is destroyed. 
  this.handle = DrawingHandle("DeltaMushModifierHandle");

  // Now setup the rendering
  InlineShader shader = this.handle.getDrawing().registerShader(OGLFlatOverlayShader());
  InlineMaterial material = shader.getOrCreateMaterial("DeltaMushModifierMaterial");

  for(Integer geomId=0; geomId<this.lines.size(); geomId++){
    String name = "DeltaMushModifier_" + String(geomId);
    InlineShape shape = InlineLinesShape(name, this.lines[geomId]);
    InlineInstance instance = SimpleInlineInstance(name + "_Instance", this.handle.rootTransform, shape, material);
    instance.setInstanceUniform(InlineUniform('u_color', Color(1.0,0.0,0.0)));
  }
}


/// Loads the data from the alembic file
/// \internal
function DeltaMushModifier.loadReferenceFromAlembic!(FilePath expandedPath){
  report("loadReferenceFromAlembic:" + expandedPath.string());
  AutoProfilingEvent p(FUNC);
  AlembicArchiveReader archive(expandedPath.string());
  String polymeshPaths[] = archive.getPathsOfType('PolyMesh');

  for(UInt32 i=0; i<polymeshPaths.size(); i++) {
    String name = BlendShapesModifier_getNameFromPath(polymeshPaths[i]);
    if(applyNameFilters(name, this.referenceGeometryNames)){
      AlembicPolyMeshReader reader = archive.getPolyMesh(polymeshPaths[i]);
      PolygonMesh mesh = PolygonMesh();
      reader.readSample(0.0, mesh);
      this.referenceGeometries.push(mesh);
    }
  }
}


function JSONDictValue DeltaMushModifier.saveJSON(PersistenceContext persistenceContext){
  JSONDictValue json = this.parent#saveJSON(persistenceContext);
  json.setInteger('iterations', this.iterations);
  json.setBoolean('displayDebugging', this.displayDebugging);
  return json;
}

function DeltaMushModifier.loadJSON!(PersistenceContext persistenceContext, JSONDictValue json){
  this.parent#loadJSON(persistenceContext, json);

  if(json.has('iterations'))
    this.iterations = json.getInteger('iterations');

  if(json.has('displayDebugging'))
    this.displayDebugging = json.getBoolean('displayDebugging');

  if(json.has('useMask'))
    this.useMask = json.getBoolean('useMask');

  if(json.has('maskWeightmapName')){
    this.maskWeightmapName = json.getString('maskWeightmapName');
    this.useMask = true;
  }

  if(!json.has('referenceGeometryNames'))
    throw("Error loading DeltaMushModifier JSON. Missing value: \"referenceGeometryNames\"");
  JSONArrayValue referenceGeometryNames = json.get('referenceGeometryNames');
  if(referenceGeometryNames)
    this.referenceGeometryNames = referenceGeometryNames.toStringArray();

  if(json.has('filePath')){
    String filePath = json.getString('filePath');

    // Check for an absolute file path, then a relative path.
    FilePath expandedPath = FilePath(filePath).expandEnvVars();

    if(expandedPath.isRelative()){
      expandedPath = FilePath(persistenceContext.filePath) / expandedPath;
    }

    if(!expandedPath.exists()){
      throw("File not found:" + expandedPath.string());
    }

    this.loadReferenceFromAlembic(expandedPath);

  }
}


