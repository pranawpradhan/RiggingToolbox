/**
    Implementation of the FABRIK IK Algorithm
    Please see http://andreasaristidou.com/publications/FABRIK.pdf for more details

Inverse Kinematics is defined as the problem of determining a set of appropriate joint
configurations for which the end effectors move to desired positions as smoothly, rapidly, and
as accurately as possible. However, many of the currently available methods suffer from high
computational cost and production of unrealistic poses. In this work, a novel heuristic method,
called Forward And Backward Reaching Inverse Kinematics (FABRIK), is described and compared with
some of the most popular existing methods regarding reliability, computational cost and
conversion criteria. FABRIK avoids the use of rotational angles or matrices, and instead finds
each joint position via locating a point on a line. Thus, it converges in fewer iterations,
has low computational cost and produces visually realistic poses.
Constraints can easily be incorporated within FABRIK and multiple links with
multiple end effectors are also easily supported.

http://www.andreasaristidou.com/FABRIK.html
Dr Andreas Aristidou

Arguments
----------
=============== ============ =====================================
Name            Type         Description
=============== ============ =====================================
basePose        Xfo[]        The initial pose of the chain. Often defined by a reference pose, or an fk pose generated by an animation system. 
goalPosition    Vec3         The goal position that the chain will be solved towards.
result          Xfo[]        The computed ik pose of the chain of bones.
=============== ============ =====================================


*/

require Math;
require Characters;


struct FABRIKChainLink : Bone {
    Xfo xfo;
    // members derived from 'Bone'
    //String	name	 
    //Scalar	length	 
    //Scalar	radius	 
    //Color	color	 
    //Integer	parentIndex	 
    //Index[]	childIndices	 
    //Integer	mirrorBoneID	 
    //UInt32	flags	 
    //Integer	shapeType	 
    //Xfo	referencePose	 
    //Mat44	invRefPose	 

    // Methods derived from 'Bone'
    //        	Bone ( in Bone other )
    //       	Bone ()
    //         	calcInvRefPose ! ()
    //       	clearFlag ! ( in UInt32 flag )
    //Bone     	clone ? ()
    //String	getDesc ? ( in String indent )
    //String	getDesc ? ()
    //        	setFlag ! ( in UInt32 flag )
    //Boolean	testFlag ? ( in UInt32 flag )
};

function FABRIKChainLink( Xfo x ){
    this.xfo = x;
    this.referencePose = x;
}

object FABRIKSolver {
    FABRIKChainLink links[]; // the bones
    Scalar  chain_length;    // length for root to end(tip) at full extension
    Integer num_bones;       // number of bone count
    Scalar  precision;       // precision
    Integer max_iteration;   // max iteration

    FABRIKChainLink tip_bone;
    FABRIKChainLink root_bone;
};


function FABRIKSolver( io Xfo xfos[] ){
    Mat44 mats[];
    mats.resize( xfos.size() );
    for (Index i = 0; i < xfos.size(); i++ ){
        mats[i] = xfos[i].toMat44();
    }

    this = FABRIKSolver( mats );
}

function FABRIKSolver( io Mat44 b[] ){
    this.precision = 0.0001f;
    this.max_iteration = 15;

    this.num_bones = b.size() - 1;
    this.links.resize( this.num_bones );

    Xfo rootXfo = Xfo( b[0] );
    Xfo parentXfo = rootXfo;
    for (Integer i=0; i < this.num_bones; i++) {
        FABRIKChainLink link;
        link.parentIndex = i-1;
        Xfo xfo( b[i] );
        link.referencePose = xfo;
        link.length = 0.0f;  // must culculate later
        link.radius = 1.0f;
        link.name = "bone" + i;

        this.links[i] = link;
        parentXfo = link.referencePose;
    }

    // calculate bone length and total chain length
    this.chain_length = 0.0f;
    //for (Index i=0; i < this.num_bones -1; i++) {
    for (Index i=0; i < this.num_bones; i++) {

        Xfo tmp_parent = this.links[i].referencePose;

        Scalar length = abs( ( b[i+1].translation() - b[i].translation()).length() );
        if ( isZero( length )) {
            setError( "zero length bone found" );
        }

        this.links[i].length = length;
        this.chain_length += length;

        report( "length["+i+"]: "+length);
    }

    // for shortcut
    this.root_bone = this.links[0];
    this.tip_bone = this.links[ this.num_bones -1 ];

}


function FABRIKSolver.EvaluateBoneTransforms!( io Mat44 out_bone_transforms[], in Vec3 effector_position ){

    Boolean is_bone_location_updated = false;
    Scalar root_to_target_distance = abs(
        ( out_bone_transforms[0].translation() - effector_position ).length
    );

    if ( root_to_target_distance > this.chain_length ) {
        // full extension
        for (Integer link_id = 1; link_id < this.num_bones; link_id++) {
            FABRIKChainLink parent = this.links[ link_id - 1 ];
            Vec3 diff = effector_position - parent.xfo.tr;
            this.links[ link_id ].xfo.tr = parent.xfo.tr + diff.normalize() * parent.length;

        }
        is_bone_location_updated = true;

    } else {
        this.SolvePosition( effector_position );
        is_bone_location_updated = true;
    }

    if (is_bone_location_updated) {

        Boolean is_rot_changed = this.SolveRotation( out_bone_transforms, effector_position );
        for (Index i = 0; i < this.num_bones; i++) {
            out_bone_transforms[i].setTranslation( this.links[i].xfo.tr );

            if (is_rot_changed) {
                out_bone_transforms[i].setRotation( this.links[i].xfo.ori );
            }
        }
    }
    //this.DrawXfo();
}



/// if effector is within reach, calculate bone translations to position tip
/// at  effector location.
// l118
function FABRIKSolver.SolvePosition!( in Vec3 effector_position ) {

    Index tip_bone_index = this.num_bones - 1;
    FABRIKChainLink tip = this.links[tip_bone_index];
    Scalar slop = abs( (tip.xfo.tr - effector_position).length ) - tip.length;
    if (slop < this.precision ) {
        return;
    }

    Integer iteration_count = 0;
    while ( (slop > this.precision) && (iteration_count < this.max_iteration) ){
        // "Forward Reaching" stage - adjust bones from End effector to Root
        this.ForwardReachOnTail( effector_position );
        for (Index link_id = tip_bone_index - 1; link_id > 0; link_id--) {
            this.ForwardReach( link_id, link_id+1 );
        }

        // "Backward Reaching" stage - adjust bones from root.
        for (Index link_id = 1; link_id < this.num_bones; link_id++ ){
            this.BackwardReach( link_id, link_id-1 );
        }
        this.BackwardReachOnTail( effector_position );

        slop = abs(
            this.links[ tip_bone_index ].length
            - distance( this.links[tip_bone_index].xfo.tr, effector_position)
        );
        iteration_count++;
    }

}


/// re-orientation of bone local axes after translation calculation
function Boolean FABRIKSolver.SolveRotation!( in Mat44 out_bone_transforms[], in Vec3 effector_position ) {
    Boolean is_changed = false;
    for (Index link_id = 0; link_id < this.num_bones; link_id++ ){
        Vec3 tail_pos;
        if ( link_id == this.num_bones - 1){
            tail_pos = effector_position;
        } else {
            tail_pos = out_bone_transforms[link_id + 1].translation();
        }

        Vec3 old_dir = tail_pos - out_bone_transforms[link_id].translation();
        if ( link_id == this.num_bones - 1){
            tail_pos = effector_position;
        } else {
            tail_pos = this.links[ link_id +1 ].xfo.tr;
        }

        Vec3 new_dir = tail_pos - this.links[ link_id ].xfo.tr;
        if ( !IsValidToEvaluate( old_dir ) || !IsValidToEvaluate( new_dir ) ){
            this.links[link_id].xfo.ori = this.links[link_id].xfo.ori;
            setError( "direction error" );
            continue;
        }
        old_dir.setUnit();
        new_dir.setUnit();

        // x axis point its tip
        Quat rot = Quat( Euler( 0, -HALF_PI, 0 , RotationOrder( 'xyz' )) );
        this.links[link_id].xfo.ori.setFromDirectionAndUpvector( new_dir, Vec3(0, 0, 100000) );
        this.links[link_id].xfo.ori *= rot;
        is_changed = true;
    }

    return is_changed;
}


function FABRIKSolver.ForwardReach!( in Integer target_index, in Integer child_index ){
    if ( target_index > this.num_bones -1 || child_index > this.num_bones -1 ){
        setError( "index > bone count ---- target:" + target_index + "  limit: " + child_index + "bone count: " + this.num_bones);
    }

    this.links[ target_index ].xfo.tr = SolveJoint(
            this.links[ target_index ].xfo,
            this.links[ child_index ].xfo,
            this.links[ target_index ].length
    );
}


/// adjust bones from root
function FABRIKSolver.BackwardReach!( in Integer target_index, in Integer parent_index ){
    if ( target_index > this.num_bones -1 || parent_index > this.num_bones -1 ){
        setError( "index > bone count ---- target:" + target_index + "  limit: " + parent_index + "bone count: " + this.num_bones);
    }
    this.links[ target_index ].xfo.tr = SolveJoint(
            this.links[ target_index ].xfo,
            this.links[ parent_index ].xfo,
            this.links[ target_index -1 ].length
    );
}

function FABRIKSolver.ForwardReachOnTail!( in Vec3 effector_position ){
    this.links[ this.num_bones -1 ].xfo.tr = SolveJoint(
            this.links[ this.num_bones -1 ].xfo.tr,
            effector_position,
            this.links[ this.num_bones -1 ].length
    );
}

function FABRIKSolver.BackwardReachOnTail!( in Vec3 effector_position ){
    this.links[ this.num_bones - 1 ].xfo.tr = SolveJoint(
            this.links[ this.num_bones - 1 ].xfo.tr,
            this.links[ this.num_bones - 1 -1 ].xfo.tr,
            this.links[ this.num_bones - 1 -1 ].length
    );
}

function FABRIKSolver.DrawXfo(){
    InlineDrawing drawing = OGLInlineDrawing_GetInstance();
    InlineTransform tra = StaticInlineTransform('characterTransform', Xfo());
    drawing.getRoot().addChild( tra );

    Xfo all[];
    all.resize( this.links.size() );

    for (Index i = 0; i < all.size(); i++ ){
        all[i] = this.links[i].xfo;
    }

    drawXfoArray( tra, "hoge", all, Color( 0, 255, 0 ), 0.5f );

}

inline Boolean IsValidToEvaluate( in Vec3 v ){
    if ( v.length == 0.0 || v.length.isNaN ){
        return false;
    }
    return true;
}

inline Vec3 SolveJoint( in Xfo a, in Xfo b, Scalar length ){
    return SolveJoint( a.tr, b.tr, length );
}

inline Vec3 SolveJoint( in Mat44 a, in Mat44 b, Scalar length ){
    return SolveJoint( a.translation(), b.translation(), length );
}

inline Vec3 SolveJoint( in Vec3 a, in Vec3 b, Scalar length ){
    Vec3 diff = a - b;
    if ( diff.length == 0 ) {
        return b;
    } else {
        return b + diff.normalize() * length;
    }
}

inline Scalar distance( in Vec3 a, in Vec3 b ){
    Vec3 diff;
    diff = a - b;
    return abs( diff.length );
}
